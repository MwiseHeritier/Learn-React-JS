<!DOCTYPE html>
<html>
  <head>
    <title>Chatbot</title>
    
    <style>
      body{
        font-family: Arial;
        margin-top: 0px;
        margin-bottom: 0px;
      }

      .send-button{
        background-color: rgb(25, 135, 84);
        color: white;
        padding: 12px 20px;
        margin-left: 10px;
        border: none;
        border-radius: 10px;
        font-size: 15px;
        cursor: pointer;
      }
      .chat-input{
        padding: 12px 15px;
        border-radius: 10px;
        border-width: 0.2px;
        font-size: 15px;

        flex-grow: 1;
      }
      .chat-input-container{
        display: flex;
        margin-bottom: 60px;
        

      }
      .app-container{
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
        height: 100vh;
        display: flex;
        flex-direction: column;
      


      }

      .chat-message-user{
        display: flex;
        justify-content: end;
        align-items: start;
      }
      .chat-message-robot{
        display: flex;
        align-items: start;

      }
      .chat-message-text{
        background-color: rgb(238, 238, 238);
        padding: 15px 20px;
        border-radius: 10px;
        margin-right: 10px;
        margin-left: 10px;
        margin-bottom: 20px;
        max-width: 300px;
      }
      
      .chat-message-profile{
        width: 45px;
      }

      .chat-messages-container{
        flex-grow: 1;
        margin-top: 20px;
        overflow: scroll;
        scrollbar-width: none;
      }
      .welcome-message {
        color: rgb(120, 120, 120);
        text-align: center;
      }
      .loading-spinner {
        height: 40px;
        margin: -15px;
      }

    </style>

  </head>
  <body>
    <div class="js-container"></div>
    
   <script src=""></script>
   <script src="https://unpkg.com/supersimpledev/react.js"></script>

   <script src="https://unpkg.com/supersimpledev/react-dom.js"></script>
    
   <script src="https://unpkg.com/supersimpledev/chatbot.js"></script>

    <script src="https://unpkg.com/supersimpledev/babel.js"></script>
    <script type="text/babel">
      
      function ChatInput({chatMessages, setChatMessages}){
        const [inputText, setInputText] = React.useState('') // initial value is empty bcz text box originally starts as empty, inputText is the current data or current text in the text box
        const [isLoading, setIsLoading] = React.useState(false);    
      
        function saveInputText(event){
          setInputText(event.target.value);
        }
        
        async  function sendMessage (){ // we async here bcz await is always inside the async
          
          // disable the send button when the we are in loading state and when input is empty
          if (isLoading || inputText === '') {
            return;
          }
          // Set isLoading to true at the start, and set it to
          // false after everything is done.
          setIsLoading(true);

          // We can put this at the top of the function or
          // after the first setChatMessages(). Both work.
          setInputText('');

        
          const newChatMessages = [ // we save this in a variable so that it will be used later.
            ...chatMessages,
            { //we adds a new chat message ata the end of the copy
              message: inputText,
              sender: 'user',
              id: crypto.randomUUID()
            },
            // Another solution is to add the Loading... message
            // to newChatMessages, but we have to remove it later.
            {
              message: <img src="loading-spinner.gif" className="loading-spinner" />,
              sender: 'robot',
              id: crypto.randomUUID()
            }
          ];
          setChatMessages(newChatMessages);

          const response = await Chatbot.getResponseAsync(inputText); //We use this object from external library in order to get response from the chatbot. The parameter we use is the message we sent
          setChatMessages([  
            // we can also use this to update update the website.
            // This makes a copy of newChatMessages, but without the
            // last message in the array.
            ...newChatMessages.slice(0, newChatMessages.length - 1),
            { 
              message: response,
              sender: 'robot',
              id: crypto.randomUUID()
            }
          ]);
           setIsLoading(false);
          //setInputText(''); // this will update the input Text in the textbox to be empty, it will not update the html yet. To update the html we need to use this inputText inside the html, we will give input element the prop called 'value'. 
        }
        function handleKeyDown(event) {
          if (event.key === 'Enter') {
            sendMessage();
          }
           else if (event.key === 'Escape') {
            setInputText('');
          }
        }
        return (
          <div className="chat-input-container">
            <input 
              placeholder= "Send a message to Chatbot" 
              size= "30" onChange={saveInputText}
              onKeyDown={handleKeyDown}
              value={inputText}
              className="chat-input"
            />

            <button onClick= {sendMessage}
              className= "send-button"
            >Send</button>
          </div>
        );
      }
      function ChatMessage({ message, sender }){
        //const message = props.message;
        // sender = props.sender;

        //const{message, sender} = props; // this will get message and sender property out of the props object and seve it in that variables
        
        /*
        if(sender === 'robot'){
          return(
            <div>
              <img src= "robot.png" width= "50"/>
              {message}
            </div>
          );
        }
        */
        
        return (
          <div className={
            sender ==='user'
              ? 'chat-message-user' 
              : 'chat-message-robot'
          }>
            {sender === 'robot' && (
              <img src= "robot.png" className="chat-message-profile"/>
            )}

            <div className="chat-message-text">
              {message}
            </div>
            
           {sender ==='user' && (
              <img src= "user.png" className="chat-message-profile"/>
            )}
          </div>
        );
      }

      function ChatMessages({chatMessages}){
        
        const chatMessageRef = React.useRef(null);
        React.useEffect(() =>{
          const containerElem = chatMessageRef.current;// we need to get HTML element we want to scroll into js
          if(containerElem){// to check if container exist
            containerElem.scrollTop = containerElem.scrollHeight;
          }
        }, [chatMessages]);
        
        return (
          <div className="chat-messages-container" ref={chatMessageRef}> 
           
            {chatMessages.map((chatMessage) => {
              return(
                <ChatMessage 
                  message = {chatMessage.message}
                  sender = {chatMessage.sender}
                  key= {chatMessage.id}
                />
              );
            })}
          </div>
        )

      }
      
      function App(){
        const [chatMessages, setChatMessages]= React.useState([]);
         
        
        //const [chatMessages, setChartMessages] = array; // array destructing shortcut, accessing the props
        //const chatMessages = array[0];
        //const setChatMessages = array[1];

        return (
          <div className="app-container">
            {chatMessages.length === 0 &&(
              <p className="welcome-message">
                Welcome to the chatbot project! Send a message using the textbox below.
              </p> 
            )}
            <ChatMessages 
              chatMessages = {chatMessages}
            />

            <ChatInput 
              chatMessages= {chatMessages}
              setChatMessages = {setChatMessages}
            />
            
          </div>
        )
      }

      
        

      const container = document.querySelector('.js-container');
      //const root = ReactDOM.createRoot(container);
      //root.render(<App />);
     
      ReactDOM.createRoot(container).render(<App />);
    </script>
  </body>
</html>

<!--
  Components
  ----------
  -> def: is a reusable, self-contained piece of UI that can have its own
  structure (HTML/JSX), styling (CSS), and behavior (JavaScript logic).
  -> A component name must start with a capital letter(PascalCase)
  -> It is the piece of website.
  -> It helps a developer to split up the website into pieces which is better practice.
  so a developer can work on a small piece of the website at a time.
  -> Every component function gets one parameter called 'props'.
  -> This props parameter is an object and it contains all attributes we give to component.
  -> We can use props to access our attributes.
  -> We use props to reuse components.
  -> most of the time we use a function when creating(naming) React components.
 
  Example
  -------
  function Header() {
    return <h1>My Website</h1>;
  }

  function App() {
    return (
      <div>
        <Header />
        <p>Welcome to my site!</p>
      </div>
    );
  }

  
  Key Features of Components
  ------------------------
  
  Reusable → Use the same component in multiple places.
  Isolated → Changes inside one component don’t break others.
  Composable → Combine small components into bigger ones.
  Props → Components can receive data from their parent.
  State → Components can store and update their own data

  Note:  Function in JSX we return only one values/element.
  But we can use div to group more element

  -> <ChatInput></ChatInput> is called component syntax(it is a react special
  syntax used to insert a component)

  -> Size attribute means how many characters can fit in this <input>

  Fragment(<></>)
  ---------------
  -> Is another way of grouping element together in React, without creating an extra <div>
  

  Guard operator (&&)
  ------------------
  ->It’s a shorter alternative to if statements or ternary operators when you only need to 
  show something in one case
  -> If value1 is true, the result will be value2 (ex: const result = value1 && value2);
  -> We can use && as an if-statement in our JSX.

  NOTE
  ----
  ->.map() takes each object in the array and save it in chatMessage parameter, this parameter
  contains chatmessage object and each chatmessage message and sender.

  ->Key helps React to track changes in the array and it should be unique.
  -> Destructuring is a JavaScript feature that lets you extract data from objects or arrays and 
  assign it to variables in a concise way

  EVENT HANDLERS
  --------------
  -> An event handler is simply a function that runs in response to an event — like a button click, 
  text input change, or form submission.
  -> For example "onclick={sendMessage}" onclick is event whicle sendMessage is an event handler
  -> We shouldn't use bracket '()' on event handler
  ->Run a function when we interact with the website

  crypto.randomUUID()
  ------------------
  -> is a JavaScript built-in method that generates a universally unique identifier
  (UUID) string in the format:

  -> We use this in sendMessage function  inorder , everytime we click button it will create 
  the unique id.

  STATE
  -----
  -> Data that is connected to the HTML.
  -> When we update this data, it will update the HTML.
  -> is a built-in object that stores data or information about 
  a component that can change over time.
  ->When state changes, React automatically re-renders the component 
  to reflect the new data in the UI.
  -> Convert some data into state we use 'React.useState()'
  ->React.useState returns/gives an array.
  -> That array has two values, the first value is array[0] is called current data
  -> in this example the first array will give us the current state value of chatMessages(current data);
  -> The second value/ element is the function(updater function) to update the current state value.
  -> The way updater function works it replaces the entire state values array with a new array
  -> -> In React, we should not modify the data directly. we should always create 
  a copy and then modify that copy, this helps React to be more efficient

  Spread Operator(...)
  --------------------
  -> It takes the values in an array and copies them into a new array.
 

  onChange property
  ---------------
  -> is an event handler used to detect and respond when the value of a form element changes.
  -> fires when the input loses focus after a change
  -> fires every time the value changes (while typing, selecting, or checking).
  -> You provide it a function (event handler) to run whenever the change happens.
  -> Every time we change the text inside the input it will run that function
  -> When onChange runs the function  inside it, It gonnna give this function one parameter.
  -> That parameter is called 'event'.
  -> Event is an object and it contains details about event or change.
  -> one detail is called event.target.
  -> event.target give us the element that we are typing in or that we change.
  ->event.target.value it give us text inside input or other elements.
  -> We can use state to save that text bcz state save data that changes over time.

  How "setInputText(event.target.value)" works
  --------------------------------------------
  -> “Hey, update inputText to this new value.”
  -> React will re-render the component with the updated text.
  
  Lifting the State Up
  -------------------
  -> means moving a state variable from a child component into a common parent component, 
  so that multiple child components can share and stay in sync with the same data.
  
  -> From this example we want to share chatMessages and setChatMessages states between ChatInput 
  and ChatMessage component so we will put it in common component called 'App'

  Why Do We Lift State Up?
  ------------------------
  ->If two or more components need to use or update the same data:
  1.Keeping that state in each child separately can cause inconsistencies.
  2.Instead, we store the state in their closest common ancestor and pass it down as props.

  Controlled input
  ----------------
  -> is an input form element (like <input>, <textarea>, or <select>) whose value is controlled by React state.
  -> For this example using the value prop we can controll the text inside the textbox using our code.

  HOOKS
  -----
  -> Hooks are functions that add state, side effects, refs, and more to functional components.
  -> Let us insert React features into our component.
  -> Hooks are useState, useEffect, useContext, useRef, useReducer, useMemo, useCallback,
  useLayoutEffect.
  -> Put hooks at the top of the component.
  -> Hooks should not be inside anything like if statements, nor function. 

  useEffect()
  ----------
  -> Run some code after the component is created or updated.
  -> In our project, after we add a chat message we want to run some code to scroll to the bottom that is
  why we used useEffect().
  ->useEffect() has two parameters those are: function to run if some thing is changed and array which controls
  when useEffect runs.
  -> If we give it an empty array, useEffect will only run once after component is created.
  ->UseEffect has two parameters first one is the function to run another is the Dependency array 
  ->[chatMessages] = run this function(first parameter) every time chatMessages changes.
  -> [chatMessages] is called 'Dependency array' it lets control when useEffect runs.it means this effect will
 re-run every time the chatMessages state changes (i.e., whenever a new message is added).

  useRef()
  -------
  ->Let us automatically save an HTML elemment from the component.
  
  Note: After the chat messages changes we want to automatically scroll to the bottom.To scroll to the bottom first we need to get the
  HTML element  that we want to scroll into our JS. in normal JS, to get HTML element we used DOM. But  in React we don't use DOM manually,
  instead we should use React features to get this element . To get this element using React we use hook called 'useRef()'.

  React will save this HTML element and save it inside 'chatMessageRef'. To access the HTML element saved inside the ref, we will write 
  chatMessageRef.current
  

  const chatMessagesRef = React.useRef(null);
  ------------------------------------------
  ->React.useRef(null) creates a ref object.
  ->Initially, .current is null because no HTML element is assigned yet.
   
  div className="chat-messages-container" ref={chatMessagesRef}>
  -------------------------------------------------------------
  -> chatMessagesRef is a ref object created with React.useRef(null).
  -> The ref prop tells React: “Hey, put this actual DOM element (<div>) into chatMessagesRef.current.”
  
  chatMessagesRef.current
  -----------------------
  ->will hold the HTML <div> element, not the individual chat messages.
  -> So it doesn’t store the chat messages themselves—it stores the container
   that holds the messages. You use this, for example, to scroll to the bottom 
   of the chat container automatically after adding a new message.

  Note: The reason we put chatMessagesRef.current inside useEffect is bcz useEffect runs after the component is created. So we need to wait 
  for the component to be created first and then we can access chat-messages-container
  
  containerElem.scrollTop = containerElem.scrollHeight;
  ----------------------------------------------------
  ->scrollTop means how far from top should we scroll? and scrollHeight gives us the total height of the element
  -> So when you set scrollTop equal to scrollHeight, the container jumps to the bottom
---



 